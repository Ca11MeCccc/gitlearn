												# 					菜鸟教程上的Git简明指南

**创建新仓库**

```
git init
会在本地仓库创建于一个.git的文件夹
```

**要记得设置自己的用户名和邮箱。在每次进行commit的时候，这两个是必须的信息**

```
1.全局设置（对所有git工程都有效）
	设置用户名：git config --global user.name  用户名
	设置邮  箱：git config --global user.email 邮箱
	
2.对特定branch（切换到工程目录下执行）
    设置用户名：git config user.name  用户名
	设置邮  箱：git config user.email 邮箱
```

**将远程仓库的代码clone下来**

```
git clone 远程仓库地址

如:
git clone https://github.com/Ca11MeCccc/gitlearn.git
```

**工作流的组成**

```
你的本地仓库由 git 维护的三棵“树”组成。

第一个是你的 工作目录，它持有实际文件；

第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；(在被隐藏起来的.git文件夹里)

最后是 HEAD，它指向你最后一次提交的结果。
```

**添加与提交**

```
1.对新增的文件进行添加
	git add 文件名
2.如果不想一个一个添加，可以
	git add * (添加所有的文件)
3.上面的add操作，是将文件add(添加)到 <暂存区>，并没有真正的存入本地的工作目录，所以我们需要将暂存区的文件提交到本地工作目录
	git commit -m "描述一下本次提交是什么的"
```

**推送改动**

```
1. 将本地工作目录的文件推送到远程仓库
git push 远程仓库别名 分支名
如：
git push origin(远程仓库通常都叫这个名字) master

如果我们的本地工作目录不是通过clone远程仓库所得到的，是我们自己创建的。那么此时这个本地工作目录是不带有远程仓库地址的，也就无法推送。所以我们可以将本地工作目录，连接到远程服务器。
2.手动将本地工作目录连接到远程服务器
git remote add origin(起什么名字都OK，但是默许的携程origin) <远程仓库地址>
```

**分支**

```
分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。
使用场景:
	现在是10.16号，还没到双11.但是领导要求我们现在就开始着手双11的活动，要开展一些新的活动。那么此时，分支的优点就来了。我们可以切换到一个新的分支上(比如就叫shuang11)，然后在此分支上进行双11活动的代码的开发。等真正的到了双11，我们再将shuang11这个分支上的代码，合并(merge)到主分支(master)上

1. 创建一个叫做“shuang11”的分支，并切换过去(在哪个分支上创建，那么shuang11的代码就和哪个分支一样。通常是在master上进行创建)
	git checkout -b shuang11(我在这里修改了！用本地的哈)
	
	如果只是创建新分支，则是
	git branch shuang11
2. 切换回主分支
	git checkout master
3. 将指定的分支删除(这里拿shuang11举例)
	git branch -d shuang11
4. 将你想要推送的分支推送到远程服务器
	git push origin <分支名>
```

**如何恢复误删的文件**

```
1. 查看工作区的变化
	git status
2. 知道哪个文件被删除了之后，reset哪个文件
	git reset <文件名，如果有很多，那就是*>
3. 取回被误删的文件
	git cheout <文件名，如果有很多，那就是*>
```

**更新与合并**

```
1. 更新本地仓库至最新改动
	git pull （pull=fetch+merge）
2. 将其他分支合并到当前分支
	(通常是将其他分支合并到master分支)
	git merge <其他分支名>
	如: git merge shuang11

```

**解决冲突**

```
在上面的两种情况下，git 都会尝试去自动合并改动。
	遗憾的是，并非每次都成功，并可能出现冲突（conflicts），即同一行的内容不一样。
		这时候就需要你修改这些文件来手动解决这些冲突（conflicts），可以使用小乌龟。
			改完之后，你需要执行如下命令以将它们标记为合并成功：
			git add <filename>
		在合并改动之前，你可以使用如下命令预览差异：
		git diff <A分支> <B分支> (以A分支为基准，B分支发生的变化)
```



---

# 							廖雪峰的Git教程

Git简介

​	Git的诞生

​	集中式 VS 分布式

安装Git

创建版本库

```
git init 
别用微软自带的记事本对文件进行编辑，打开可以，修改不行
```

```
git add <文件名>
将文件添加到暂存区
```

```
git commit -m "写上本次提交的备注(不可省略)"
将暂存区的文件提交到当前分支
```

时光机穿梭

```
git status
可以查看此刻工作区的状态
```

```
git diff [文件名] [版本A] [版本B]
可以比较版本A和版本B的[文件名]的不同
```

​	版本回退

```
HEAD指向的版本就是当前版本，因此Git可以让我们子版本之间来回穿梭，使用git reset --hard <commitId>

可以用git log来确定此版本之前的版本
可以用git reflog来确定此版本之后的版本
```

​	工作区和暂存区

```
git的本地文件系统就分为3个。一个是工作区working directory，一个暂存区stage(也可以想象成是一个缓冲区的存在)，一个被提交的分支(通常是master)。

每次在本地的工作区working directory进行文件的修改之后，我们需要将这些被修改的(或者是新增的)文件添加到暂存区stage，然后将暂存区stage中的修改commit(提交)到分支中(通常是master)。这样的话，暂存区(stage)就被清空了。
```

​	管理修改(git的本质是对文件的修改进行管理)

```
每次修改，如果不用git add到暂存区，那就不会加入到commit中
(也就是说，并非工作区所有的文件都是需要添加到暂存区并提交到分支的。如果你没有将此文件进行add，那么就让他留在自己的本地工作区working directory，其他人也不知道！)
```

​	撤销修改

```
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，
分两步，
	第一步用命令git reset HEAD <file>，就回到了场景1，	第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库(提交了就惨咯)。
```

​	删除文件

```
rm <文件名> ： 是直接把文件彻底的删除掉了
我们现在有两种选择：
  1. 我们删除了这个文件，也确实要从版本库中删除该文件。我们可以使用git rm <文件名>，然后commit提交到分支，这样一来，版本库(分支)中这个文件也就真的被删除了(想拿回来可以回退版本，然后取出文件啊，然后再粘贴到最新版本，再add，再commit)
  2. 我们删除了这个文件，但是发现误删了，需要取回这个文件。因为版本库里面还有，所有可以很轻松的将被误删的文件回退到最新版本.
  	git checkout -- <文件名>
  git checkout 的作用就是用版本库里面的版本，来替换工作区的版本。无论工作区修改还是删除，都可以一键还原。
  
  /**
   * 注意：从来没有被添加到版本库(分支)里就被删除的文件，    * 是无法恢复的！
   */
   
 git rm 用于删除一个文件。
 如果这个文件已经被提交到了版本库，那么永远不用担心被误删。但是你要想恢复的话，只能恢复到最新版本，即会丢失<最近的一次提交commit>之后<你又修改的内容>
```

远程仓库

​	添加远程仓库

```
实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。
```

​	从远程仓库克隆

```
git clone来克隆一个远程仓库到本地
```

分支管理

```
分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！

分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。
```

创建与合并分支

```
在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。

截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。

HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，
(master，branch等相当于指向分支的指针，HEAD是指向master，branch指针的)

所以，HEAD指向的就是当前分支。

一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：


每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。

当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：

你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！

不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：

假如我们在dev上的工作完成了，就可以把dev合并到master上。

Git怎么合并呢？

最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：
```

![](https://static.liaoxuefeng.com/files/attachments/919022412005504/0)



```
所以Git合并分支也很快！就改改指针，工作区内容也不变！

合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：
```

![](https://static.liaoxuefeng.com/files/attachments/919022479428512/0)

​	

`git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：

```
$ git branch dev
$ git checkout dev
Switched to branch 'dev
```





```
参考文档:
1. https://blog.csdn.net/seasermy/article/details/94719709

2. https://www.runoob.com/manual/git-guide/

3. https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424
```

